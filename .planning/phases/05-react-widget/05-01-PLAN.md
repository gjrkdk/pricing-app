---
phase: 05-react-widget
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - app/routes/api.v1.products.$productId.price.ts
  - app/services/product-matrix-lookup.server.ts
  - app/routes/api.v1.draft-orders.ts
  - app/validators/api.validators.ts
autonomous: true

must_haves:
  truths:
    - "Price API response includes currency code, dimension ranges, and unit preference"
    - "Draft Order can be created via REST API with API key authentication"
    - "Widget can fetch all data it needs from a single price API call"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Store model with currency field"
      contains: "currency"
    - path: "app/routes/api.v1.products.$productId.price.ts"
      provides: "Extended price response with currency, dimensionRange, unit"
      contains: "dimensionRange"
    - path: "app/routes/api.v1.draft-orders.ts"
      provides: "POST endpoint for Draft Order creation via REST"
      exports: ["action"]
    - path: "app/validators/api.validators.ts"
      provides: "Zod schema for draft order request body"
      contains: "DraftOrderSchema"
  key_links:
    - from: "app/routes/api.v1.draft-orders.ts"
      to: "app/services/draft-order.server.ts"
      via: "imports createDraftOrder"
      pattern: "createDraftOrder"
    - from: "app/routes/api.v1.products.$productId.price.ts"
      to: "app/services/product-matrix-lookup.server.ts"
      via: "lookupProductMatrix returns dimension ranges"
      pattern: "dimensionRange"
---

<objective>
Extend the Phase 4 REST API to support the React widget's needs: currency in price responses, dimension ranges for client-side validation, and a new Draft Order creation endpoint.

Purpose: The widget needs (1) currency code for Intl.NumberFormat formatting, (2) min/max dimension ranges for placeholder hints and client-side validation, (3) unit preference for display, and (4) a REST endpoint to create Draft Orders with API key auth (Phase 3's service uses embedded app auth which isn't available from external storefronts).

Output: Extended price API response + new POST /api/v1/draft-orders endpoint
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/routes/api.v1.products.$productId.price.ts
@app/services/product-matrix-lookup.server.ts
@app/services/draft-order.server.ts
@app/services/price-calculator.server.ts
@app/utils/api-auth.server.ts
@app/utils/rate-limit.server.ts
@app/validators/api.validators.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add currency field to Store model and extend product-matrix-lookup</name>
  <files>prisma/schema.prisma, app/services/product-matrix-lookup.server.ts</files>
  <action>
1. Add `currency` field to Store model in prisma/schema.prisma:
   - `currency String @default("USD")` — ISO 4217 code, defaults to USD
   - Place it after `unitPreference`

2. Run `npx prisma migrate dev --name add-store-currency` to create and apply migration.

3. Extend `ProductMatrixResult` in product-matrix-lookup.server.ts to include dimension ranges:
   - Add to the return type: `dimensionRange: { minWidth: number; maxWidth: number; minHeight: number; maxHeight: number }`
   - Add `unit: string` (from store's unitPreference)
   - Add `currency: string` (from store's currency field)
   - To get store data, the function already receives `storeId` — query the Store to get `unitPreference` and `currency`
   - Calculate dimension ranges from the sorted breakpoints: minWidth = first width breakpoint value, maxWidth = last width breakpoint value, same for height

4. Update the function signature to return the new `ProductMatrixResult` type:
   ```typescript
   export interface ProductMatrixResult {
     matrixData: MatrixData;
     matrixName: string;
     dimensionRange: {
       minWidth: number;
       maxWidth: number;
       minHeight: number;
       maxHeight: number;
     };
     unit: string;
     currency: string;
   }
   ```
  </action>
  <verify>
    - `npx prisma migrate status` shows no pending migrations
    - `npx tsc --noEmit` passes (TypeScript compiles)
  </verify>
  <done>Store model has currency field with USD default. ProductMatrixResult includes dimensionRange, unit, and currency.</done>
</task>

<task type="auto">
  <name>Task 2: Extend price API response with currency, dimensionRange, and unit</name>
  <files>app/routes/api.v1.products.$productId.price.ts</files>
  <action>
Update the price endpoint to include the new fields from the extended ProductMatrixResult in its JSON response.

In the success response (step 8), change from:
```json
{
  "price": unitPrice,
  "currency": "store-default",
  "dimensions": { "width": ..., "height": ..., "unit": store.unitPreference },
  "quantity": ...,
  "total": ...,
  "matrix": productMatrix.matrixName
}
```

To:
```json
{
  "price": unitPrice,
  "currency": productMatrix.currency,
  "dimensions": { "width": ..., "height": ..., "unit": productMatrix.unit },
  "quantity": ...,
  "total": ...,
  "matrix": productMatrix.matrixName,
  "dimensionRange": productMatrix.dimensionRange
}
```

Key changes:
- Replace `"store-default"` with `productMatrix.currency` (real ISO 4217 code)
- Replace `store.unitPreference` with `productMatrix.unit` (same value, but now from lookup result)
- Add `dimensionRange` object with `minWidth`, `maxWidth`, `minHeight`, `maxHeight`
- The `store` variable from `authenticateApiKey` is still used for auth and rate limiting, but product matrix lookup now provides the display data

Note: The `authenticateApiKey` function returns `store.unitPreference` too, but we use the value from `lookupProductMatrix` to keep the response data source consistent. Both should be identical since they query the same store.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Start dev server and test with curl:
      ```
      curl -s -H "X-API-Key: YOUR_KEY" "http://localhost:PORT/api/v1/products/PRODUCT_ID/price?width=50&height=50" | python3 -m json.tool
      ```
    - Response should include `currency` (e.g., "USD"), `dimensionRange` object with min/max values, and `dimensions.unit` (e.g., "mm")
  </verify>
  <done>Price API response includes real currency code, dimension range bounds, and unit preference. The "store-default" placeholder is replaced with actual ISO 4217 currency code.</done>
</task>

<task type="auto">
  <name>Task 3: Create POST /api/v1/draft-orders REST endpoint</name>
  <files>app/routes/api.v1.draft-orders.ts, app/validators/api.validators.ts</files>
  <action>
1. Add `DraftOrderSchema` to `app/validators/api.validators.ts`:
   ```typescript
   export const DraftOrderSchema = z.object({
     productId: z.string().refine(
       (id) => /^\d+$/.test(id) || /^gid:\/\/shopify\/Product\/\d+$/.test(id),
       { message: 'Product ID must be numeric or GID format' }
     ),
     width: z.number().positive("Width must be a positive number"),
     height: z.number().positive("Height must be a positive number"),
     quantity: z.number().int().positive().default(1),
   });
   ```

2. Create `app/routes/api.v1.draft-orders.ts` as a resource route (no default export):

   This endpoint:
   - Authenticates via X-API-Key (reuse `authenticateApiKey`)
   - Rate limits (reuse `checkRateLimit`)
   - Validates JSON body with `DraftOrderSchema`
   - Normalizes productId to GID format
   - Looks up the product matrix (reuse `lookupProductMatrix`)
   - Creates a Shopify admin client for the store using `@shopify/shopify-app-remix` authenticate
   - Calls `createDraftOrder` from Phase 3's service

   IMPORTANT: The existing `createDraftOrder` service requires a Shopify `admin` GraphQL client (from `authenticate.admin`). For REST API requests (not embedded app requests), we need to create the admin client differently. Use the store's `accessToken` from the database to make Shopify GraphQL calls directly:

   ```typescript
   // Instead of authenticate.admin (which needs embedded session),
   // create a minimal GraphQL client using the store's access token
   async function createShopifyAdmin(shop: string, accessToken: string) {
     return {
       graphql: async (query: string, options?: { variables?: Record<string, any> }) => {
         const response = await fetch(
           `https://${shop}/admin/api/2024-01/graphql.json`,
           {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-Shopify-Access-Token': accessToken,
             },
             body: JSON.stringify({
               query,
               variables: options?.variables,
             }),
           }
         );
         return {
           json: () => response.json(),
         };
       },
     };
   }
   ```

   The action handler:
   - Handles OPTIONS for CORS preflight (return 204)
   - For POST: authenticate, rate-limit, parse JSON body, validate, look up matrix, create admin client, call createDraftOrder
   - For other methods: return 405
   - All responses wrapped with `withCors()` (copy the same pattern from price endpoint)

   Response format on success (201):
   ```json
   {
     "draftOrderId": "gid://shopify/DraftOrder/123",
     "name": "#D18",
     "checkoutUrl": "https://shop.myshopify.com/...",
     "total": "45.00",
     "price": 15.00,
     "dimensions": { "width": 50, "height": 50, "unit": "mm" },
     "quantity": 3
   }
   ```

   Note: The existing `createDraftOrder` doesn't return `checkoutUrl`. To get it, extend the GraphQL mutation response in `draft-order.server.ts` to also select `invoiceUrl` from the draftOrder (this is the customer-facing checkout URL). Add `invoiceUrl` to the returned `draftOrder` object. Alternatively, construct it from the draft order ID — but `invoiceUrl` from the mutation is more reliable.

   Actually, to avoid modifying the existing draft-order service (which is tested and working for the embedded app), create a NEW function `createDraftOrderFromRest` in the draft-orders route file itself that:
   - Takes the validated input + store info
   - Queries the product matrix (already have lookupProductMatrix)
   - Calculates price (already have calculatePrice)
   - Creates the Shopify admin client using store's access token
   - Makes the GraphQL mutation (copy the mutation from draft-order.server.ts but also select `invoiceUrl`)
   - Saves the DraftOrderRecord (reuse the same Prisma pattern)

   This avoids coupling the REST endpoint to the embedded app's auth patterns.

   Error responses use RFC 7807 format (same as price endpoint).

   To get the store's access token, extend `authenticateApiKey` return type OR query it separately. Simplest: query the store with accessToken in the draft-orders route:
   ```typescript
   const storeWithToken = await prisma.store.findUnique({
     where: { id: store.id },
     select: { accessToken: true, shop: true },
   });
   ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exists at `app/routes/api.v1.draft-orders.ts`
    - Route exports `action` function (no default export — resource route)
  </verify>
  <done>POST /api/v1/draft-orders endpoint exists with API key auth, Zod validation, Draft Order creation via Shopify GraphQL, and RFC 7807 error format. Returns draftOrderId, checkout URL, total, and dimension info. CORS headers on all responses.</done>
</task>

</tasks>

<verification>
1. `npx prisma migrate status` — no pending migrations
2. `npx tsc --noEmit` — TypeScript compiles
3. Price API response includes `currency`, `dimensionRange`, and `dimensions.unit` fields
4. POST /api/v1/draft-orders route file exists with action export
5. DraftOrderSchema exists in api.validators.ts
</verification>

<success_criteria>
- GET /api/v1/products/:id/price returns currency code (not "store-default"), dimension range bounds, and unit
- POST /api/v1/draft-orders accepts productId/width/height/quantity, authenticates via X-API-Key, creates Draft Order, returns checkout URL
- All new endpoints follow established patterns: CORS, rate limiting, RFC 7807 errors, Zod validation
</success_criteria>

<output>
After completion, create `.planning/phases/05-react-widget/05-01-SUMMARY.md`
</output>
