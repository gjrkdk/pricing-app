---
phase: 05-react-widget
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - packages/widget/src/hooks/usePriceFetch.ts
  - packages/widget/src/hooks/useDraftOrder.ts
  - packages/widget/src/components/DimensionInput.tsx
  - packages/widget/src/components/PriceDisplay.tsx
  - packages/widget/src/components/QuantitySelector.tsx
  - packages/widget/src/components/AddToCartButton.tsx
autonomous: true

must_haves:
  truths:
    - "Price fetches are debounced ~400ms after input stops"
    - "Price display shows skeleton shimmer while loading"
    - "Dimension inputs show inline validation errors below each field"
    - "Quantity can be adjusted with +/- buttons"
    - "Add to Cart button is disabled until dimensions are valid and price is loaded"
  artifacts:
    - path: "packages/widget/src/hooks/usePriceFetch.ts"
      provides: "Debounced price fetching with loading/error states and dimension range"
      contains: "useDebounce"
    - path: "packages/widget/src/hooks/useDraftOrder.ts"
      provides: "Draft Order creation with loading state"
      contains: "createDraftOrder"
    - path: "packages/widget/src/components/DimensionInput.tsx"
      provides: "Text input with inline validation errors and range hints"
      contains: "error"
    - path: "packages/widget/src/components/PriceDisplay.tsx"
      provides: "Price display with skeleton loader and Intl.NumberFormat"
      contains: "NumberFormat"
    - path: "packages/widget/src/components/QuantitySelector.tsx"
      provides: "Quantity input with +/- buttons"
      contains: "increment"
    - path: "packages/widget/src/components/AddToCartButton.tsx"
      provides: "Disabled button with loading spinner"
      contains: "disabled"
  key_links:
    - from: "packages/widget/src/hooks/usePriceFetch.ts"
      to: "REST API GET /api/v1/products/:id/price"
      via: "fetch with X-API-Key header"
      pattern: "X-API-Key"
    - from: "packages/widget/src/hooks/useDraftOrder.ts"
      to: "REST API POST /api/v1/draft-orders"
      via: "fetch POST with JSON body"
      pattern: "draft-orders"
    - from: "packages/widget/src/components/PriceDisplay.tsx"
      to: "Intl.NumberFormat"
      via: "useMemo cached formatter"
      pattern: "NumberFormat"
---

<objective>
Build the widget's custom hooks (data fetching logic) and internal UI components (visual building blocks).

Purpose: These are the atomic pieces that the main PriceMatrixWidget will compose. Hooks handle all API communication (debounced price fetching, Draft Order creation). Components handle all visual rendering (inputs, price display, quantity, button). Separating these from the main widget keeps each piece focused and testable.

Output: 2 hooks + 4 components, all importable by PriceMatrixWidget in Plan 04
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-react-widget/05-CONTEXT.md
@.planning/phases/05-react-widget/05-RESEARCH.md
@.planning/phases/05-react-widget/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePriceFetch and useDraftOrder hooks</name>
  <files>packages/widget/src/hooks/usePriceFetch.ts, packages/widget/src/hooks/useDraftOrder.ts</files>
  <action>
1. Create `packages/widget/src/hooks/` directory.

2. Create `packages/widget/src/hooks/usePriceFetch.ts`:

   This hook manages the debounced price fetching lifecycle. It:
   - Accepts apiUrl, apiKey, productId
   - Exposes width/height state + setters
   - Debounces width and height values at 400ms (within the 300-500ms range per user decision)
   - Fetches price from `GET {apiUrl}/api/v1/products/{productId}/price?width={w}&height={h}&quantity={q}`
   - Sends `X-API-Key` header
   - Returns price, loading, error, currency, dimensionRange, unit
   - On FIRST successful fetch, stores dimensionRange and currency (these don't change between calls for same product)
   - Only fetches when BOTH debounced width and height are non-empty and numeric
   - Accepts quantity parameter (for total calculation)
   - Uses AbortController to cancel in-flight requests when inputs change
   - Handles RFC 7807 error responses: extract `detail` field for user-friendly messages

   Implementation details:
   ```typescript
   import { useState, useEffect, useRef, useCallback } from 'react';
   import { useDebounce } from 'use-debounce';
   import type { PriceApiResponse } from '../types';

   interface UsePriceFetchOptions {
     apiUrl: string;
     apiKey: string;
     productId: string;
   }

   interface UsePriceFetchReturn {
     width: string;
     height: string;
     setWidth: (v: string) => void;
     setHeight: (v: string) => void;
     price: number | null;
     total: number | null;
     loading: boolean;
     error: string | null;
     currency: string | null;
     unit: string | null;
     dimensionRange: PriceApiResponse['dimensionRange'] | null;
   }
   ```

   Key behaviors:
   - `price` is null until first valid fetch (per user decision: "No price shown until customer enters valid width and height")
   - `loading` is true during fetch (triggers skeleton in PriceDisplay)
   - `error` contains user-friendly message from API's `detail` field
   - On 401 error, set error to "Authentication failed" (don't expose API key details)
   - AbortController cleanup on unmount prevents state updates after unmount

3. Create `packages/widget/src/hooks/useDraftOrder.ts`:

   This hook manages Draft Order creation. It:
   - Accepts apiUrl, apiKey
   - Exposes `createDraftOrder(params)` async function
   - Tracks `creating` (boolean) and `error` (string | null) states
   - POSTs to `{apiUrl}/api/v1/draft-orders` with JSON body: `{ productId, width, height, quantity }`
   - Sends `X-API-Key` header and `Content-Type: application/json`
   - Returns `{ draftOrderId, checkoutUrl, total, price, dimensions, quantity }` on success
   - Handles RFC 7807 errors same as usePriceFetch

   Implementation:
   ```typescript
   import { useState, useCallback } from 'react';
   import type { DraftOrderApiResponse } from '../types';

   interface UseDraftOrderOptions {
     apiUrl: string;
     apiKey: string;
   }

   interface CreateDraftOrderParams {
     productId: string;
     width: number;
     height: number;
     quantity: number;
   }

   interface UseDraftOrderReturn {
     createDraftOrder: (params: CreateDraftOrderParams) => Promise<DraftOrderApiResponse>;
     creating: boolean;
     error: string | null;
   }
   ```
  </action>
  <verify>
    - `ls packages/widget/src/hooks/usePriceFetch.ts packages/widget/src/hooks/useDraftOrder.ts` — both exist
    - usePriceFetch.ts imports `useDebounce` from 'use-debounce'
    - usePriceFetch.ts uses AbortController for request cancellation
    - useDraftOrder.ts POSTs to /api/v1/draft-orders
    - `cd packages/widget && npx tsc --noEmit` — check that hooks compile (may fail on missing PriceMatrixWidget import in index.ts, but hooks themselves should have no type errors)
  </verify>
  <done>usePriceFetch hook debounces at 400ms, fetches price with X-API-Key, exposes price/loading/error/currency/dimensionRange/unit state. useDraftOrder hook POSTs to draft-orders endpoint, exposes createDraftOrder/creating/error. Both handle RFC 7807 errors and cleanup on unmount.</done>
</task>

<task type="auto">
  <name>Task 2: Create internal UI components</name>
  <files>packages/widget/src/components/DimensionInput.tsx, packages/widget/src/components/PriceDisplay.tsx, packages/widget/src/components/QuantitySelector.tsx, packages/widget/src/components/AddToCartButton.tsx</files>
  <action>
1. Create `packages/widget/src/components/` directory.

2. Create `packages/widget/src/components/DimensionInput.tsx`:
   - Props: `label` (string, e.g., "Width"), `value` (string), `onChange` (callback), `unit` (string | null, e.g., "cm"), `min` (number | null), `max` (number | null), `error` (string | null)
   - Renders a text input (NOT number type — text field per user decision)
   - Shows unit as suffix inside/after the input (e.g., "cm")
   - Shows dimension range as placeholder text: e.g., "30 - 100" when min/max available
   - Shows helper text below input: e.g., "30 - 100 cm" (per user decision: "Show valid dimension range upfront as placeholder/helper text")
   - Shows inline validation error below input when `error` is provided (per user decision: "Inline validation errors under each field")
   - Error text styled with `var(--pm-error-color)` CSS variable
   - CSS classes: `pm-dimension-input`, `pm-dimension-label`, `pm-dimension-field`, `pm-dimension-unit`, `pm-dimension-helper`, `pm-dimension-error`
   - Input uses `inputMode="decimal"` for mobile numeric keyboard

3. Create `packages/widget/src/components/PriceDisplay.tsx`:
   - Props: `price` (number | null), `currency` (string | null), `loading` (boolean), `error` (string | null)
   - When `price === null && !loading && !error`: render nothing (empty initial state per user decision)
   - When `loading`: render skeleton/shimmer placeholder (use a simple CSS animation shimmer, NOT react-loading-skeleton — avoid the extra dependency since we're in Shadow DOM and the library's CSS injection won't work inside Shadow DOM). Create a simple `<div className="pm-skeleton">` with CSS shimmer animation.
   - When `error`: render error message styled with `var(--pm-error-color)`
   - When `price` and `currency`: format with `Intl.NumberFormat(navigator.language, { style: 'currency', currency })` — cache formatter with useMemo
   - CSS classes: `pm-price-display`, `pm-price-value`, `pm-price-error`, `pm-skeleton`

   IMPORTANT: Do NOT use react-loading-skeleton inside Shadow DOM. The library injects `<style>` tags into document.head, which won't be visible inside Shadow DOM. Use a custom CSS shimmer animation instead:
   ```css
   .pm-skeleton {
     background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
     background-size: 200% 100%;
     animation: pm-shimmer 1.5s infinite;
     border-radius: var(--pm-border-radius);
     height: 32px;
     width: 120px;
   }
   @keyframes pm-shimmer {
     0% { background-position: -200% 0; }
     100% { background-position: 200% 0; }
   }
   ```

4. Create `packages/widget/src/components/QuantitySelector.tsx`:
   - Props: `quantity` (number), `onChange` (callback: (qty: number) => void)
   - Renders a quantity display with "-" and "+" buttons flanking a number display
   - "-" button disabled when quantity <= 1
   - "+" button always enabled (no upper bound for v1)
   - CSS classes: `pm-quantity`, `pm-quantity-btn`, `pm-quantity-value`, `pm-quantity-label`
   - Label "Quantity" above the selector

5. Create `packages/widget/src/components/AddToCartButton.tsx`:
   - Props: `onClick` (callback), `disabled` (boolean), `loading` (boolean)
   - Renders a button with text "Add to Cart"
   - When `disabled`: button is disabled (per user decision: "Button disabled until both dimensions are valid and price is loaded")
   - When `loading`: show a CSS spinner inside the button replacing the text (per user decision: "Loading spinner inside button while Draft Order is being created")
   - Button uses `var(--pm-primary-color)` for background
   - CSS classes: `pm-add-to-cart`, `pm-add-to-cart-spinner`
   - Spinner is a simple CSS-only spinner (border animation), not a third-party component

All components are INTERNAL — they are NOT exported from index.ts. They are imported only by PriceMatrixWidget.
  </action>
  <verify>
    - All 4 component files exist in packages/widget/src/components/
    - DimensionInput accepts label, value, onChange, unit, min, max, error props
    - PriceDisplay uses Intl.NumberFormat with useMemo (no react-loading-skeleton dependency)
    - QuantitySelector has +/- buttons with disabled state on "-" when qty=1
    - AddToCartButton has disabled and loading props with CSS spinner
    - `cd packages/widget && npx tsc --noEmit` — components compile (ignore PriceMatrixWidget missing error from index.ts)
  </verify>
  <done>4 internal components created: DimensionInput (text fields with inline validation, range hints, unit suffix), PriceDisplay (Intl.NumberFormat currency formatting, CSS shimmer skeleton, error state), QuantitySelector (+/- buttons), AddToCartButton (disabled state, CSS loading spinner). All use CSS custom properties for theming. No external CSS dependencies (Shadow DOM compatible).</done>
</task>

</tasks>

<verification>
1. All 6 files exist: 2 hooks + 4 components
2. usePriceFetch uses use-debounce at 400ms
3. PriceDisplay uses CSS shimmer (not react-loading-skeleton) for Shadow DOM compatibility
4. DimensionInput shows range helper text and inline errors
5. AddToCartButton disabled when `disabled=true`, shows spinner when `loading=true`
6. All components use `pm-` prefixed CSS classes and CSS custom property variables
</verification>

<success_criteria>
- Hooks handle all API communication (debounced price fetch, Draft Order creation)
- Components handle all visual rendering per locked decisions from CONTEXT.md
- No external CSS library dependencies (all styles Shadow DOM compatible)
- All components use CSS custom properties for theming
- DimensionInput shows dimension range hints (per user decision)
- PriceDisplay shows skeleton shimmer while loading (per user decision)
- AddToCartButton disabled until valid + price loaded (per user decision)
</success_criteria>

<output>
After completion, create `.planning/phases/05-react-widget/05-03-SUMMARY.md`
</output>
