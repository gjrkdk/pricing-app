---
phase: 11-data-model-price-calculation
plan: 03
type: tdd
wave: 2
depends_on: ["11-01"]
files_modified:
  - app/services/option-price-calculator.server.ts
  - app/services/option-price-calculator.server.test.ts
autonomous: true

must_haves:
  truths:
    - "Fixed modifiers (positive and negative) add/subtract correct cent amounts to base price"
    - "Percentage modifiers calculate from base matrix price using basis points with ceiling round-up"
    - "Multiple modifiers stack additively (non-compounding) from the base price"
    - "Total price never goes below $0.00 (silently capped at 0)"
    - "All arithmetic uses integers (cents) with no floating-point operations"
    - "Price breakdown shows base price, each modifier amount, and final total"
  artifacts:
    - path: "app/services/option-price-calculator.server.ts"
      provides: "Price calculation with option modifiers using integer arithmetic"
      exports: ["calculatePriceWithOptions", "calculateModifierAmount"]
      min_lines: 50
    - path: "app/services/option-price-calculator.server.test.ts"
      provides: "Comprehensive test suite for option price calculation"
      min_lines: 100
  key_links:
    - from: "app/services/option-price-calculator.server.ts"
      to: "app/services/price-calculator.server.ts"
      via: "takes base price output as input (basePriceCents parameter)"
      pattern: "basePriceCents"
    - from: "app/services/option-price-calculator.server.test.ts"
      to: "app/services/option-price-calculator.server.ts"
      via: "import of calculatePriceWithOptions and calculateModifierAmount"
      pattern: "import.*calculatePriceWithOptions.*from"
---

<objective>
Implement and test the option price calculation engine using TDD (Red-Green-Refactor). This is pure business logic with defined inputs and outputs — a perfect TDD candidate.

Purpose: The price calculation engine is the core of the option groups feature. Getting the math right (integer arithmetic, ceiling rounding, non-compounding percentages, floor at $0.00) is critical for merchant trust and financial correctness. TDD ensures correctness through comprehensive edge case coverage.

Output: Fully tested price calculation module with integer-only arithmetic, non-compounding percentage modifiers, and price breakdown generation.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-data-model-price-calculation/11-01-SUMMARY.md
@app/services/price-calculator.server.ts
@app/services/price-calculator.server.test.ts
</context>

<feature>
  <name>Option Price Calculator with Integer Arithmetic</name>
  <files>app/services/option-price-calculator.server.ts, app/services/option-price-calculator.server.test.ts</files>
  <behavior>
**Types:**

```typescript
interface PriceModifier {
  type: 'FIXED' | 'PERCENTAGE';
  value: number;  // FIXED: cents, PERCENTAGE: basis points (10000 = 100%)
  label: string;  // e.g. "Tempered glass", "Economy finish"
}

interface ModifierBreakdown {
  label: string;
  type: 'FIXED' | 'PERCENTAGE';
  originalValue: number;  // raw modifier value as stored
  appliedAmountCents: number;  // actual cents added/subtracted
}

interface PriceBreakdownResult {
  basePriceCents: number;
  modifiers: ModifierBreakdown[];
  totalCents: number;
}
```

**Function: `calculateModifierAmount(basePriceCents: number, modifier: PriceModifier): number`**

Returns the cents amount for a single modifier:
- FIXED: returns modifier.value directly (already in cents)
- PERCENTAGE: returns Math.ceil((basePriceCents * modifier.value) / 10000) — ceiling round-up per user decision

Cases:
- calculateModifierAmount(1000, {type:'FIXED', value:500, label:'X'}) -> 500
- calculateModifierAmount(1000, {type:'FIXED', value:-500, label:'X'}) -> -500
- calculateModifierAmount(1000, {type:'PERCENTAGE', value:1000, label:'X'}) -> 100 (10% of $10.00)
- calculateModifierAmount(1000, {type:'PERCENTAGE', value:1500, label:'X'}) -> 150 (15% of $10.00)
- calculateModifierAmount(1000, {type:'PERCENTAGE', value:-1500, label:'X'}) -> -150 (Math.ceil(-1.50) = -1, wait no: Math.ceil(-150) not needed since it's already integer... actually: (1000 * -1500) / 10000 = -150.0 exactly. But for non-exact: (999 * 1500) / 10000 = 149.85 -> Math.ceil = 150)
- calculateModifierAmount(999, {type:'PERCENTAGE', value:1500, label:'X'}) -> 150 (ceiling of 149.85)
- calculateModifierAmount(1000, {type:'PERCENTAGE', value:0, label:'X'}) -> 0
- calculateModifierAmount(1000, {type:'FIXED', value:0, label:'X'}) -> 0

**IMPORTANT for negative percentages with ceiling:**
Math.ceil rounds TOWARD positive infinity. So Math.ceil(-149.85) = -149, NOT -150.
This is correct behavior — for negative modifiers, ceiling means "less negative" which is the round-up analog (favorable to merchant).

Cases for negative percentage rounding:
- calculateModifierAmount(999, {type:'PERCENTAGE', value:-1500, label:'X'}) -> -149 (Math.ceil(-149.85) = -149)

**Function: `calculatePriceWithOptions(basePriceCents: number, modifiers: PriceModifier[]): PriceBreakdownResult`**

Calculation order (per user decision):
1. Start with base matrix price in cents
2. For each modifier, calculate amount from BASE price (non-compounding)
3. Sum base + all modifier amounts
4. Floor at $0.00 (Math.max(0, total))

Cases:
- No modifiers: (1000, []) -> { basePriceCents: 1000, modifiers: [], totalCents: 1000 }
- Single fixed: (1000, [{type:'FIXED', value:500, label:'Glass'}]) -> totalCents: 1500
- Single percentage: (1000, [{type:'PERCENTAGE', value:1000, label:'Coating'}]) -> totalCents: 1100
- Multiple mixed: (1000, [{type:'FIXED', value:500, label:'A'}, {type:'PERCENTAGE', value:1000, label:'B'}]) -> totalCents: 1600 (1000 + 500 + 100)
- Negative fixed (discount): (1000, [{type:'FIXED', value:-300, label:'Discount'}]) -> totalCents: 700
- Negative percentage: (1000, [{type:'PERCENTAGE', value:-1500, label:'Economy'}]) -> totalCents: 850 (1000 - 150)
- Floor at zero: (1000, [{type:'FIXED', value:-1500, label:'Big discount'}]) -> totalCents: 0 (not -500)
- Floor at zero with percentage: (500, [{type:'PERCENTAGE', value:-10000, label:'100% off'}]) -> totalCents: 0
- Multiple percentages non-compounding: (1000, [{type:'PERCENTAGE', value:1000, label:'A'}, {type:'PERCENTAGE', value:500, label:'B'}]) -> totalCents: 1150 (1000 + 100 + 50, NOT 1000*1.1*1.05=1155)
- Zero base price: (0, [{type:'FIXED', value:500, label:'A'}]) -> totalCents: 500
- Zero base with percentage: (0, [{type:'PERCENTAGE', value:1000, label:'A'}]) -> totalCents: 0 (0% of 0)
- All zero modifiers: (1000, [{type:'FIXED', value:0, label:'A'}, {type:'PERCENTAGE', value:0, label:'B'}]) -> totalCents: 1000
- Breakdown includes each modifier: verify modifiers array in result has correct label, type, originalValue, appliedAmountCents for each modifier

**Rounding edge cases:**
- calculateModifierAmount(333, {type:'PERCENTAGE', value:3333, label:'X'}) -> Math.ceil(333 * 3333 / 10000) = Math.ceil(110.9889) = 111
- calculateModifierAmount(1, {type:'PERCENTAGE', value:1, label:'X'}) -> Math.ceil(1 * 1 / 10000) = Math.ceil(0.0001) = 1 (rounds up any fraction)
  </behavior>
  <implementation>
Implement as pure functions with NO database dependency and NO floating-point arithmetic in the critical path.

1. `calculateModifierAmount`: switch on modifier.type, FIXED returns value directly, PERCENTAGE returns Math.ceil((base * value) / 10000)

2. `calculatePriceWithOptions`: map modifiers through calculateModifierAmount, sum all amounts, add to base, Math.max(0, total), build breakdown object

Follow the pattern of `price-calculator.server.ts` — pure functions, clear JSDoc, exported types.

**RED phase:** Write all test cases first. Tests MUST fail (functions don't exist yet). Commit: `test(11-03): add failing tests for option price calculator`

**GREEN phase:** Implement both functions minimally to pass all tests. Commit: `feat(11-03): implement option price calculator with integer arithmetic`

**REFACTOR phase (if needed):** Clean up, add JSDoc, extract constants. Commit: `refactor(11-03): clean up option price calculator`
  </implementation>
</feature>

<verification>
1. `npx vitest run app/services/option-price-calculator.server.test.ts` — all tests pass
2. No `parseFloat`, `toFixed`, or decimal arithmetic in the source (only integer operations)
3. Math.ceil used for percentage calculations
4. Math.max(0, ...) used for floor at zero
5. All test values are integers (cents/basis points)
6. Price breakdown includes correct label, type, originalValue, and appliedAmountCents for each modifier
</verification>

<success_criteria>
- All test cases from behavior section pass
- calculateModifierAmount correctly handles FIXED and PERCENTAGE with ceiling rounding
- calculatePriceWithOptions correctly stacks modifiers additively (non-compounding)
- Negative modifiers reduce the price correctly
- Floor at $0.00 prevents negative totals
- Price breakdown provides transparent modifier details
- Zero-cost modifiers show $0.00 (0 cents) consistently
- Pure functions with no database or external dependencies
- TDD commits: RED (failing tests) -> GREEN (implementation) -> REFACTOR (cleanup)
</success_criteria>

<output>
After completion, create `.planning/phases/11-data-model-price-calculation/11-03-SUMMARY.md`
</output>
