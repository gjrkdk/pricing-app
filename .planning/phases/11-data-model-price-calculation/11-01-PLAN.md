---
phase: 11-data-model-price-calculation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/migrations/XXXXXXXX_add_option_groups/migration.sql
autonomous: true

must_haves:
  truths:
    - "OptionGroup, OptionChoice, and ProductOptionGroup tables exist in the database"
    - "Option groups belong to a store and cascade-delete when store is deleted"
    - "Option choices belong to an option group with either FIXED or PERCENTAGE modifier type"
    - "Option groups can be assigned to products via junction table with unique constraint"
    - "Foreign keys have manual indexes for PostgreSQL query performance"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "OptionGroup, OptionChoice, ProductOptionGroup models with ModifierType and GroupRequirement enums"
      contains: "model OptionGroup"
    - path: "prisma/migrations"
      provides: "SQL migration creating option group tables and enums"
  key_links:
    - from: "prisma/schema.prisma (OptionGroup)"
      to: "prisma/schema.prisma (Store)"
      via: "storeId foreign key with onDelete: Cascade"
      pattern: "store\\s+Store\\s+@relation"
    - from: "prisma/schema.prisma (OptionChoice)"
      to: "prisma/schema.prisma (OptionGroup)"
      via: "optionGroupId foreign key with onDelete: Cascade"
      pattern: "optionGroup\\s+OptionGroup\\s+@relation"
    - from: "prisma/schema.prisma (ProductOptionGroup)"
      to: "prisma/schema.prisma (ProductMatrix)"
      via: "productId relation through ProductMatrix.productId"
      pattern: "product\\s+ProductMatrix\\s+@relation"
---

<objective>
Create the database schema for option groups, option choices, and product-option group assignments with proper enums, constraints, indexes, and cascade rules.

Purpose: Establish the data model foundation that all subsequent option group features (CRUD, price calculation, API, widget) depend on. Without this schema, no option group functionality can be built.

Output: Updated Prisma schema with 3 new models (OptionGroup, OptionChoice, ProductOptionGroup) and 2 new enums (ModifierType, GroupRequirement), plus a generated migration.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@prisma/schema.prisma
@app/db.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add option group models and enums to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the following to `prisma/schema.prisma`:

**Enums:**

1. `ModifierType` enum with values `FIXED` and `PERCENTAGE`, mapped to `"modifier_type"`.

2. `GroupRequirement` enum with values `REQUIRED` and `OPTIONAL`, mapped to `"group_requirement"`.

**Models:**

3. `OptionGroup` model mapped to `"option_groups"`:
   - `id` String @id @default(cuid())
   - `storeId` String @map("store_id") — FK to Store.id with onDelete: Cascade
   - `name` String — e.g. "Glass Type", "Edge Finish"
   - `requirement` GroupRequirement @default(OPTIONAL) @map("requirement") — per user decision: per-group required/optional setting
   - `createdAt` DateTime @default(now()) @map("created_at")
   - `updatedAt` DateTime @updatedAt @map("updated_at")
   - `store` Store relation
   - `choices` OptionChoice[] relation
   - `products` ProductOptionGroup[] relation
   - `@@index([storeId])` — manual FK index for PostgreSQL
   - `@@map("option_groups")`

4. `OptionChoice` model mapped to `"option_choices"`:
   - `id` String @id @default(cuid())
   - `optionGroupId` String @map("option_group_id") — FK to OptionGroup.id with onDelete: Cascade
   - `label` String — e.g. "Tempered glass", "Economy glass"
   - `modifierType` ModifierType @map("modifier_type") — FIXED or PERCENTAGE
   - `modifierValue` Int @map("modifier_value") — For FIXED: cents (500 = $5.00). For PERCENTAGE: basis points (1000 = 10.00%). Required, non-nullable per research recommendation. Negative values allowed per user decision.
   - `isDefault` Boolean @default(false) @map("is_default") — for optional groups, merchant-set default choice
   - `createdAt` DateTime @default(now()) @map("created_at")
   - `optionGroup` OptionGroup relation
   - `@@index([optionGroupId])` — manual FK index for PostgreSQL
   - `@@map("option_choices")`

5. `ProductOptionGroup` model mapped to `"product_option_groups"`:
   - `id` Int @id @default(autoincrement())
   - `productId` String @map("product_id") — FK to ProductMatrix.productId (references productId, not id)
   - `optionGroupId` String @map("option_group_id") — FK to OptionGroup.id with onDelete: Cascade
   - `assignedAt` DateTime @default(now()) @map("assigned_at")
   - `product` ProductMatrix relation (fields: [productId], references: [productId], onDelete: Cascade)
   - `optionGroup` OptionGroup relation (fields: [optionGroupId], references: [id], onDelete: Cascade)
   - `@@unique([productId, optionGroupId])` — prevent duplicate assignments
   - `@@index([productId])` — manual FK index
   - `@@index([optionGroupId])` — manual FK index
   - `@@map("product_option_groups")`

**Updates to existing models:**

6. Add `optionGroups OptionGroup[]` relation to `Store` model.

7. Add `optionGroups ProductOptionGroup[]` relation to `ProductMatrix` model.

**IMPORTANT notes per user decisions:**
- Display order is alphabetical (no displayOrder column needed) — user decision
- No multi-select — single-select only (no selectionMode field needed)
- Cap enforcement (20 choices per group, 5 groups per product) is application-level only, NOT database constraints — per research recommendation
- `modifierValue` is required (non-nullable) Int — NULL has no semantic meaning, use 0 for zero-cost
- `isDefault` on OptionChoice (not a defaultChoiceId on OptionGroup) — simpler, avoids cross-table FK validation
  </action>
  <verify>Run `npx prisma validate` to confirm schema is valid. Run `npx prisma generate` to confirm client generation succeeds with the new types.</verify>
  <done>Schema validates without errors. Prisma Client generates with OptionGroup, OptionChoice, ProductOptionGroup types, ModifierType enum, and GroupRequirement enum available.</done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply database migration</name>
  <files>prisma/migrations/XXXXXXXX_add_option_groups/migration.sql</files>
  <action>
Generate the migration for the new option group schema:

```bash
npx prisma migrate dev --name add_option_groups
```

This will:
1. Create an SQL migration file with CREATE TYPE for the two enums and CREATE TABLE for the three new models
2. Apply the migration to the local database
3. Regenerate the Prisma Client

After migration, verify:
- The migration SQL contains `CREATE TYPE "modifier_type"` and `CREATE TYPE "group_requirement"`
- The migration SQL contains `CREATE TABLE "option_groups"`, `CREATE TABLE "option_choices"`, `CREATE TABLE "product_option_groups"`
- Foreign key constraints reference correct tables and columns
- Unique constraint on `(product_id, option_group_id)` exists in product_option_groups
- All `CREATE INDEX` statements for foreign key columns are present

If `prisma migrate dev` fails in the non-interactive environment, use the manual migration workflow from Phase 3:
```bash
mkdir -p prisma/migrations/$(date +%Y%m%d%H%M%S)_add_option_groups
npx prisma migrate diff --from-schema-datamodel prisma/schema.prisma.bak --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/TIMESTAMP_add_option_groups/migration.sql
npx prisma migrate deploy
```
(Back up schema.prisma before changes as schema.prisma.bak first, or use --from-migrations-directory)
  </action>
  <verify>Run `npx prisma migrate status` to confirm migration is applied. Run `npx prisma db pull --force` and diff against schema.prisma to confirm database matches schema.</verify>
  <done>Migration file exists in prisma/migrations/, migration status shows "Database schema is up to date", and `npx prisma generate` succeeds.</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes
2. `npx prisma generate` succeeds
3. Migration SQL file exists with correct tables, enums, indexes, and constraints
4. `npx prisma migrate status` shows schema is up to date
5. TypeScript compilation succeeds with new types: `import { OptionGroup, OptionChoice, ProductOptionGroup, ModifierType, GroupRequirement } from "@prisma/client"`
</verification>

<success_criteria>
- Three new database tables created: option_groups, option_choices, product_option_groups
- Two new PostgreSQL enums created: modifier_type, group_requirement
- All foreign keys have manual indexes
- Cascade delete rules: Store -> OptionGroup -> OptionChoice, ProductMatrix -> ProductOptionGroup, OptionGroup -> ProductOptionGroup
- Unique constraint on (productId, optionGroupId) in junction table
- Existing tables (Store, ProductMatrix) updated with new relations
- Prisma Client types available for downstream plans
</success_criteria>

<output>
After completion, create `.planning/phases/11-data-model-price-calculation/11-01-SUMMARY.md`
</output>
