---
phase: 11-data-model-price-calculation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - app/validators/option-group.validators.ts
  - app/services/option-group.server.ts
autonomous: true

must_haves:
  truths:
    - "Option groups can be created with a name, requirement setting, and choices with modifiers"
    - "Option groups can be read with their choices and product assignment count"
    - "Option groups can be assigned to and unassigned from products"
    - "Validation enforces caps (20 choices per group, 5 groups per product) and data integrity"
    - "Only one choice per optional group can be marked as default"
  artifacts:
    - path: "app/validators/option-group.validators.ts"
      provides: "Zod schemas for option group create/update input validation"
      exports: ["OptionGroupCreateSchema", "OptionGroupUpdateSchema", "ProductOptionGroupAssignSchema"]
    - path: "app/services/option-group.server.ts"
      provides: "CRUD operations for option groups, choices, and product assignments"
      exports: ["createOptionGroup", "getOptionGroup", "listOptionGroups", "updateOptionGroup", "deleteOptionGroup", "assignOptionGroupToProduct", "unassignOptionGroupFromProduct", "getProductOptionGroups", "countProductsUsingGroup"]
  key_links:
    - from: "app/services/option-group.server.ts"
      to: "app/db.server.ts"
      via: "prisma import for database queries"
      pattern: "import.*prisma.*from.*db\\.server"
    - from: "app/validators/option-group.validators.ts"
      to: "app/services/option-group.server.ts"
      via: "validated input types used in service functions"
      pattern: "OptionGroupCreateInput|OptionGroupUpdateInput"
---

<objective>
Create Zod validation schemas and a service layer for option group CRUD operations, including creating/reading/updating/deleting option groups with choices, and assigning/unassigning option groups to products.

Purpose: Provides the validated data layer that the Admin UI (Phase 12) and API extension (Phase 13) will consume. Separates validation and business logic from route handlers following the existing service pattern.

Output: Two new files — validation schemas and service module with full CRUD + assignment operations.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-data-model-price-calculation/11-01-SUMMARY.md
@prisma/schema.prisma
@app/db.server.ts
@app/validators/api.validators.ts
@app/services/product-matrix-lookup.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas for option groups</name>
  <files>app/validators/option-group.validators.ts</files>
  <action>
Create `app/validators/option-group.validators.ts` following the pattern in `app/validators/api.validators.ts`.

**Schemas to create:**

1. `OptionChoiceInputSchema` — validates a single choice within an option group:
   - `label`: z.string().min(1, "Label is required").max(100, "Label must be 100 characters or fewer")
   - `modifierType`: z.enum(["FIXED", "PERCENTAGE"])
   - `modifierValue`: z.number().int("Modifier value must be a whole number") — for FIXED: cents (e.g. 500 = $5.00), for PERCENTAGE: basis points (e.g. 1000 = 10%). Negative values allowed per user decision.
   - `isDefault`: z.boolean().default(false)

2. `OptionGroupCreateSchema` — validates option group creation:
   - `name`: z.string().min(1, "Name is required").max(100, "Name must be 100 characters or fewer")
   - `requirement`: z.enum(["REQUIRED", "OPTIONAL"]).default("OPTIONAL")
   - `choices`: z.array(OptionChoiceInputSchema).min(1, "At least one choice is required").max(20, "Maximum 20 choices per group")
   - Add `.refine()` to ensure at most one choice has `isDefault: true`
   - Add `.refine()` to ensure `isDefault: true` is only set when requirement is "OPTIONAL" (required groups don't need defaults — they must always be selected)

3. `OptionGroupUpdateSchema` — validates option group updates:
   - `name`: z.string().min(1).max(100).optional()
   - `requirement`: z.enum(["REQUIRED", "OPTIONAL"]).optional()
   - `choices`: z.array(OptionChoiceInputSchema.extend({ id: z.string().optional() })).min(1).max(20).optional()
   - Same refinements as create for defaults

4. `ProductOptionGroupAssignSchema` — validates assigning a group to a product:
   - `productId`: z.string().min(1, "Product ID is required")
   - `optionGroupId`: z.string().min(1, "Option group ID is required")

Export all schemas AND their inferred TypeScript types:
```typescript
export type OptionGroupCreateInput = z.infer<typeof OptionGroupCreateSchema>;
export type OptionGroupUpdateInput = z.infer<typeof OptionGroupUpdateSchema>;
export type OptionChoiceInput = z.infer<typeof OptionChoiceInputSchema>;
```
  </action>
  <verify>TypeScript compilation passes. Import the schemas in a scratch file and verify that valid and invalid inputs parse correctly.</verify>
  <done>All four Zod schemas export correctly with TypeScript types. Refinements enforce single-default and cap limits at validation time.</done>
</task>

<task type="auto">
  <name>Task 2: Create service layer for option group CRUD and assignments</name>
  <files>app/services/option-group.server.ts</files>
  <action>
Create `app/services/option-group.server.ts` following the existing service pattern in `app/services/product-matrix-lookup.server.ts` (import prisma from `~/db.server`, return null for not-found, never throw on expected errors).

**Functions to implement:**

1. `createOptionGroup(storeId: string, input: OptionGroupCreateInput)`:
   - Use `prisma.optionGroup.create()` with nested `choices: { create: [...] }` for atomic creation
   - Return the created option group with choices included

2. `getOptionGroup(id: string, storeId: string)`:
   - Fetch option group by ID with choices included, ordered alphabetically by label
   - Validate store ownership (return null if storeId doesn't match)
   - Include `_count: { select: { products: true } }` to show how many products use this group (needed for "Used by N products" warning per user decision)

3. `listOptionGroups(storeId: string)`:
   - Fetch all option groups for the store, ordered alphabetically by name (per user decision)
   - Include choice count and product assignment count via `_count`

4. `updateOptionGroup(id: string, storeId: string, input: OptionGroupUpdateInput)`:
   - Verify store ownership first (return null if not found or wrong store)
   - If choices provided: delete all existing choices, create new ones (replace strategy — simpler than diffing)
   - Use transaction for atomic update: `prisma.$transaction([deleteChoices, updateGroup])`
   - Return updated option group with choices

5. `deleteOptionGroup(id: string, storeId: string)`:
   - Verify store ownership
   - Delete using `prisma.optionGroup.delete()` — cascade rules handle choices and product assignments
   - Return `{ deleted: true }` or null if not found

6. `assignOptionGroupToProduct(productId: string, optionGroupId: string, storeId: string)`:
   - Verify the option group belongs to the store
   - Verify the product (ProductMatrix) belongs to the store
   - Count existing assignments for this product — enforce cap of 5 groups per product (application-level per research recommendation)
   - Create ProductOptionGroup record
   - Return the assignment or throw with descriptive error for cap violation

7. `unassignOptionGroupFromProduct(productId: string, optionGroupId: string)`:
   - Delete the ProductOptionGroup record matching both IDs
   - Return `{ removed: true }` or null if not found

8. `getProductOptionGroups(productId: string, storeId: string)`:
   - Fetch all option groups assigned to a product via ProductOptionGroup junction
   - Include full choices for each group, choices ordered alphabetically by label
   - Groups ordered alphabetically by name (per user decision)
   - Validate that the product belongs to the store
   - Return array of option groups with choices, or null if product not found/unauthorized

9. `countProductsUsingGroup(optionGroupId: string)`:
   - Return count of products using this option group (for "Used by N products" warning)
   - Simple `prisma.productOptionGroup.count({ where: { optionGroupId } })`

**Pattern notes:**
- Follow existing pattern: import `{ prisma } from "~/db.server"`
- Store ownership validation on all reads and writes (same as product-matrix-lookup.server.ts)
- Return null for not-found/unauthorized, never throw on expected errors
- Use Prisma transactions for multi-step operations
  </action>
  <verify>TypeScript compilation passes. All exported functions have correct signatures. Imports resolve correctly.</verify>
  <done>Service module exports 9 functions covering full CRUD for option groups and product assignment management. All functions validate store ownership. Cap enforcement (5 groups per product) is application-level.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (TypeScript compilation)
2. `app/validators/option-group.validators.ts` exports 4 schemas with inferred types
3. `app/services/option-group.server.ts` exports 9 functions
4. All functions validate store ownership
5. Validation schemas enforce: max 20 choices, single default, required fields
6. Service layer enforces: max 5 groups per product
</verification>

<success_criteria>
- Zod schemas validate option group create/update inputs with proper constraints
- Service layer provides complete CRUD for option groups
- Service layer provides assign/unassign for product-option group relationships
- Store ownership validated on every operation
- Application-level caps enforced (20 choices per group, 5 groups per product)
- Existing codebase patterns followed (import paths, return conventions, error handling)
</success_criteria>

<output>
After completion, create `.planning/phases/11-data-model-price-calculation/11-02-SUMMARY.md`
</output>
